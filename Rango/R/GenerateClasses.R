# Project: Rango
# 
# Author: Willem Ligtenberg - willem.ligtenberg@openanalytics.eu
###############################################################################

#' Root class to identify classes generated by Rango
#' @name RangoObject-class
#' @include RangoConnection.R
#' @exportClass RangoObject
setClass("RangoObject")


# TODO This we might require for an update method
setReplaceMethod("$", "RangoObject", function(x, name, value) {
      eval(substitute(x@slot <- value, list(slot = name, value = value)))
      x
    })

setMethod("$", "RangoObject", function(x, name){
      tryCatch({
        if(!eval(substitute(x@slot@rangoBookKeeping[["retrieved"]], 
                list(slot = name)))){
          return(retrieve(eval(substitute(x@slot, list(slot = name))), 
                  x@rangoBookKeeping[["dbc"]]))
        }
        return(eval(substitute(x@slot, list(slot = name))))
      }, error = function(cond){
        return(eval(substitute(x@slot, list(slot = name))))
      })
    })

setGeneric(
    name = "retrieveAll",
    def = function(object){standardGeneric("retrieveAll")})

setMethod("retrieveAll", "RangoObject", function(object){
      dbc <- object@rangoBookKeeping[["dbc"]]
      slotsToRetrieve <- nonEmptySlots(object, dbc)
      for(name in slotsToRetrieve){
        if(eval(substitute(inherits(object@slot, "RangoObject"), list(slot = name)))){
          if(!eval(substitute(object@slot@rangoBookKeeping[["retrieved"]], 
                  list(slot = name)))){
            eval(substitute(object@slot <- retrieve(object@slot, dbc), list(slot = name)))
          }
        }
      }
      return(object)
    })

#' list the tables for the current data base 
#' @name listTables
#' 
#' @param dbc RangoConnection
#' @return vector containing table names in the data base
#' 
#' @author Willem Ligtenberg
#' @docType methods
#' @export
setGeneric(
    name = "listTables",
    def = function(dbc){standardGeneric("listTables")})

#' Detect the data type of the argument
#' @param columnDataRow specific row of the description of a table
#' @return data type as a string
#' @author Willem Ligtenberg
#' @importFrom Hmisc capitalize
dataType <- function(columnDataRow){
  retVal <- NA
  if(is.na(columnDataRow$foreignkey)){
    retVal <- switch(columnDataRow$type, 
        boolean = "logical",
        integer = "numeric",
        real = "numeric",
        text = "character",
        'timestamp with time zone' = "POSIXct",
        float = "numeric",
        'double precision[]' = "list",
        'double precision' = "numeric",
        'integer[]' = "list",
        'text[]' = "list")
    if(is.null(retVal) & grepl("character varying", columnDataRow$type)){
      retVal <- "character"
    }
  } else{
    retVal <- capitalize(columnDataRow$foreignkey)
  }
  return(retVal)
}

#' determine the required fields of a table
#' @param columnData data of a specific column of the data table
#' @return string with the required fields concatenated
#' @author Willem Ligtenberg
requiredFields <- function(columnData){
  retval <- ""
  requiredData <- columnData[columnData$notnull == TRUE, ]
  if(nrow(requiredData)){
    indices <- which(is.na(requiredData$default) | 
            grepl("nextval", requiredData$default))
    retval <- paste(paste(requiredData[is.na(requiredData$default), "name"], 
            collapse = ", "), paste(paste(requiredData[!indices, "name"], 
                requiredData[!indices, "default"], sep = " = "), sep = ", "), 
        if(nrow(requiredData[grepl("nextval", requiredData$default),])){
          paste(paste(
                  requiredData[grepl("nextval", requiredData$default), "name"], 
                  "NULL", sep = " = "), sep = ", ")}, sep = ", ")
    retval <- sub(", , ", ", ", retval)
    retval <- sub(", $", "", retval)
  }		
  return(retval)
}

#' determine the optional fields of a table
#' @param columnData data of a specific column of the data table
#' @return string with the optional fields concatenated
#' @author Willem Ligtenberg
#' @export
optionalField <- function(columnData){
  retval <- ""
  optionalData <- columnData[columnData$notnull == FALSE, ]
  if(nrow(optionalData)){
    retval <- paste(paste(paste0(
                optionalData[is.na(optionalData$default), "name"], 
                " = NULL"), collapse = ", "), 
        paste(paste(optionalData[!is.na(optionalData$default), "name"], 
                optionalData[!is.na(optionalData$default), "default"], 
                sep = " = "), sep = ", "), sep = ", ")
    retval <- sub(", $", "", retval)
  }
  return(retval)
}

#' generate S4 classes and functions for a specific table in the data base
#' @name generateClass
#' 
#' @param dbc RangoConnection
#' @param tableName name of the table
#' @return string containing the class definition
#' 
#' @author Willem Ligtenberg
#' @docType methods
#' @export
setGeneric(
    name = "generateClass",
    def = function(dbc, tableName){standardGeneric("generateClass")})


#' generate S4 classes and functions for a specific table in the data base
#' @param dbc RangoConnection
#' @param fileName file name to write the classes to 
#' @author Willem Ligtenberg
#' @export 
generateClasses <- function(dbc = rangoConnection(), fileName = "dbClasses.R"){
  codeFile <- file(fileName, "w")  # open an output file connection
  tables <- listTables(dbc)
  for(tableName in tables){
    code <- generateClass(dbc, tableName)
    writeLines(code, con = codeFile)
  }
  close(codeFile)
}

#' generate S4 classes and functions for a specific table in the data base and
#' loads them into memory
#' @param dbc RangoConnection
#' @author Willem Ligtenberg
#' @export 
loadClasses <- function(dbc){
  code <- ""
  tables <- listTables(dbc)
  for(tableName in tables){
    codeBlock <- generateClass(dbc, tableName)
    code <- paste(code, paste(codeBlock, collapse = "\n"), sep = "\n")
  }
  Rango:::unlockEnvironment(.getNamespace("Rango"))
  suppressWarnings(source(textConnection(code), keep.source = FALSE, local = .getNamespace("Rango")))
  suppressWarnings(source(textConnection(code), keep.source = FALSE, local = .getNamespace("Rango")))
  lockEnvironment(.getNamespace("Rango"), bindings = TRUE)
  rangoResult <- new.env(parent = globalenv())
  suppressMessages(suppressWarnings(source(textConnection(code), keep.source = FALSE, 
              local = rangoResult)))
  suppressMessages(suppressWarnings(source(textConnection(code), keep.source = FALSE, 
              local = rangoResult)))
  attach(rangoResult, name = "rangoResult")
}
